SICP
====


Ĉapitro 1a
----------


Subĉapitro 1.2: Proceduroj kaj la Procezoj ke Ili Generas
---------------------------------------------------------

- Ĉi tio subĉapitro priparolas pri, kiel oni devas percepti la efikoj (aŭ sekvoj) de la verkitaj
  procezoj.

### la 22-an de Januaro 2018

- mi ne certas, pri la signifo de la de demando de ekzerco 1,28, tamen, mi nun realigis la esencon
  de la nova funkcio. Tamen, mi ne certas pri la aldona provo kiu mi bezonas fari (la problemo volas
  min por kontroli se la (square (expmod base (/ exp 2) m)) egalas al (modulo 1 m), tamen, la
  numeroj ne de devas egali al 1 aŭ (- n 1))

### la 21-an de Januaro 2018

- puŝis la solvon de ekzerco 1,27. Nune laboras pri ekzerco 1,28, kiu estas pri la modifiko de la
  Fermat provo por eligi la ĝustan eligon eĉ la donita argumenta numero estas ekzemplo de Carmichael
  numero. Mi jam kreis pli simplan version de la bezonata respondo, tamen, la ekzerco bezonas min
  por modifiki la jaman funkcion kiu estas nomita expmod (kaj por aldoni aldonan provon, por ke, la
  provo de la Miller-Rabin provo ne estas simila al la provo de la Fermat provo)

### la 19-an de Januaro 2018

- puŝis la solvon de ekzerco 1,25 kaj 1,26. Mi pensas nune, pri la kialo kial la Carmichael numeroj
  havas la kapablon por mistifiki la Fermat provon (krom la fakto, ke la ekzemploj en la piednoto 47
  estas nur dividebla per 3, 5, kaj 7) (ekzerco 1,27)

### la 18-an de Januaro 2018

- puŝis la solvon de ekzerco 1,24, kaj nune pensas se mia komenca klarigo de ekzerco 1,25 estas
  fakte ĝusta, kaj finfine, mi preskaŭ finita per la tuta klarigo de ekzerco 1,26 (ekzerco 1,23
  ankoraŭ konfuzas min.)

### la 15-an de Januaro 2018

- la klarigo de ekzerco 1,23 estas preskaŭ fina, tamen, mi pensas, ke la klarigo estas nur teorio
  (la sola klarigo ke mi povas doni estas, ĉar la ekzamenaj ekzemploj inter la du ŝanĝoj enhavas
  multe da duplikatoj signifas, ke la multiganto inter la ekzamenaj ekzemploj de (+ 1
  test-divisor) kaj (next-divisor) estas ne ekzakte du), sed, la ĉefa klarigo de ekzerco 1,24 estas
  nun plena, tamen, mi puŝos ĝin poste, tial ke, mi pensas, ke mi povas aldoni pli detalon al la
  klarigo.

### la 14-an de Januaro 2018

- nune laboras la solvon de ekzerco 1,24. Mi ne ankoraŭ puŝis la solvon de ekzerco 1,23, tial ke, la
  klarigo ne estas ankoraŭ tuta, ĉar mi nur havas unu klarigon, kial la nova funkcio ne havas la
  atenditan agmanieron (la rapida multiganto, ekzakte).

### la 12-an de Januaro 2018

- puŝis la solvon de ekzerco 1,22. Preskaŭ fina pri la ekspliko de ekzerco 1,23, tamen, mi nune
  pensas la kaŭzon, kial la bezonata tempo por provi (se la numeroj estas prima) ne estas
  multiplikite ekzakte per du, kiam la testkazo estas nun duona (ĉar anstataŭe 2,3,4,5,6..., estas
  nun nur 2,3,5,7,9 (eble, tial ke, ekzistas duplikataj numeroj, ekzemple 2 kaj 3, tamen, mi devas
  certa pri mia verdikto antaŭ mi puŝas mian solvon))

### la 11-an de Januaro 2018

- nune serĉas la botelkolon (se ĝi vere ekzistas en la funkcio, aŭ mi nur estas paranoja) en ekzerco
  1,23. Ne ankoraŭ puŝis ekzerco 1,22, ĉar mi havis ne progreson, tiam, mi progresis al ekzerco
  1,23, tiam mi serĉis mian eraron pri ekzerco 1,22.

### la 9-an de Januaro 2018

- preskaŭ fina pri ekzerco 1,22, tamen, mi rimarkis bizaran interagon inter la `cons` kaj `display`
  funkcioj, do, se mi ne povas serĉi alian metodon por eligi la eligon, aŭ mi ne povas ripari la
  interagon inter `cons` kaj `display`, eble, mi setlos sur tion solvon, interdume.

### la 7-an de Januaro 2018

- nune laboras por solvi la diversajn problemojn en ekzerco 1,22, kiu diras min, ke mi bezonas krei,
  eble, du procezon (la unua procezo provas testi, se la intersekva nepara numero estas prima; la
  dua procezo volas min por krei funkcion, ke serĉas la tri plej malgrandajn neparajn numerojn post
  '1000', '10000', '100000', kaj '1000000')(SICP diras ke, la dua procezo bezonas la unuan procezo
  por funkcii bone).

### la 5-an de Januaro 2018

- nune laboras pri ekzerco 1,22, nune legas pri la teoremo de /Fermat/, kaj nune provas fari kelke
  da eksperimentojn pri la modifado de kelke da procezo en subĉapitro 1,2,6.

### la 4-an de Januaro 2018

- puŝis la solvan dosieron de ekzerco 1,21, kiu estas pri la koda elvolvo de le `smallest-divisor`
  funkcio

### la 2-an de Januaro 2018

- nune laboras pri ekzerco 1,21, kiam mi provas elvolvi `(smallest-divisor 199)`, `(smallest-divisor
  1999)`, kaj `(smallest-divisor 19999)`.

### la 1-an de Januaro 2018

- finis modifiki ekzercon 1,20 (pri ĝia strukturo)

### la 31-an de Decembro 2017

- finis labori la ekzerco 1,20, tamen, mi bezonas purigi la strukturon de mia solvo (ĉar la koda
  malvolve estas nune malpura) antaŭ mi puŝas la dosieron al /GitLab/

### la 29-an de Decembro 2017

- ne progreso ankoraŭ pri ekzerco 1,19. Mi ne tute scias la metodo por kalkuli la valorojn de 'p'
  kaj 'q'

### la 28-an de Decembro 2017

- ne tute pensas pri la enhavoj de '??'. Mi ne certas, se mi devas uzi `count` por kalkuli la novajn
  valorojn de `p` kaj `q`

### la 26-an de Decembro 2017

- ne progreso ankoraŭ pri ekzerco 1,19. Mi eĉ penis la metodo de provoj kaj eraroj, tamen, mi scias,
  ke mi ne devas fari ĝin, tamen, mia nur konsileto estas, ke mi devas komputi la /p'/ kaj /q'/, per
  uzi la malnovajn valorojn de /p/ kaj /q/.

### la 22-an de Decembro 2017

- ne povas pensi pri la graveco de /(* b p)/ kaj /(* a p)/ en la /else case/ de ekzerco 1,19.

### la 21-an de Decembro 2017

- en la origina funkcio, mi rimarkis ke, kiam la numero estas multiplikite per 'q', la numero ne
  sanĝas, kaj kiam la numero estas multiplikite per 'p', la numero sanĝas al '0'. Tamen, mi ne
  ankoraŭ scias la sekvan valoron de 'p' kaj 'q', por ke, kiam 'a' kaj 'b' estas multiplikite per la
  nova valoro de 'p' kaj 'q' (kiam 'count' ne plu estas parnombro), la novaj valoroj (de 'a' kaj
  'b') estas simila al la valoroj ke la origina funkcio rezultas, eble.

### la 19-an de Decembro 2017

- ne povas kalkuli la modelo de procezo de la unua /fibonacci/ funkcio en ekzerco 1,19 por krei
  novan procezon ke havas /O(log n)/ de kreskado

### la 18-an de Decembro 2017

- (ne povas koncentrigi al la problemo ĉar la adaptila problemo)

### la 17-an de Decembro 2017

- nune laboras sur ekzerco 1,19, pri la itercia versio de /fibonacci/ funkcio ke havas /O(log n)/
  kreskado en paŝoj.

### la 15-an de Decembro 2017

- puŝis la solvojn por ekzercoj 1,16, 1,17, kaj finfine, 1,18.

### la 14-an de Decembro 2017

- SICP 1,16
  + devas purigi la klarigo de ekzerco

### la 12-an de Decembro 2017

- SICP 1,16
  + traduku la probleman deklaron

### la 11-an de Decembro 2017

- SICP 1,16
  + la itercia versio nune funkcias kiam la enigo estas nepara numero, do, mi vere bezonas decidi
    kiel la akumulejan valoro kreskos kiam la enigo estas para numero

### la 10-an de Decembro 2017

- SICP 1,16
  + laboras en ekzerco 1,16, pri la iteracian version de la `O(log n)` version de la `expt` funkcio

### la 8-an de Decembro 2017

- SICP 1.15
  + puŝis `ex-01-15.rkt`

### la 7-an de Decembro 2017

- SICP 1.14 kaj 1.15
  + puŝis `ex-01-14.rkt` al Gitlab kaj nune laboras sur `ex-01-15.rkt`

### la 4-an de Decembro 2017

- SICP 1.13
  + puŝis `ex-01-13.rkt` al Gitlab

### la 3-an de Decembro 2017

- SICP 1.12
  + puŝis `ex-01-12.rkt` al GitLab

### la 1-an de Decembro 2017

- SICP 1.12
  + finis la kodan dividaĵon de la ekzerco, nur la eksplika dividaĵon estas restanta

### la 28-an de Novembro 2017

- SICP 1.12
  + dimandis por asisto el la mentoro

### la 27-an de Novembro 2017

- SICP 1.12
  + reiris al la ekesto tial ke, eble, mi ne tute komprenas la problemon

### la 24-an de Novembro 2017

- SICP 1.12
  + problemo el 23a de Novembro, 2017 ankoraŭ postrestas (sed la efiko nun havas pli unuforman
    efikon (unua dua numeroj de ĉiu fazo de la PT estas elmontris certe))

### la 23-an de Novembro 2017

- nune sur SICP 1.12
  + havas problemo per kiel aldoni la fina 1 al ne dua enigo al funkcio (kio okazas nune estas, post
    la sumo de la dua numeroj malsub ĝin, estos senprokraste progresas al la sekva rikura proceso
    sen aldonante la fina 1, unue)
  + havas problemo sur kiel alpaŝi per “pli-ol-3” “ena” numeroj (tial ke, havante la 1 “ena” numero
    estas simple la aldonante de la antaŭa valoro de la iteraciero)

### la 21-an de Novembro 2017

- finfine kreis progreson ankoraŭ sur Triangulo de Paskalo per uzante `cons` sur la `else case` de
la ĉefparto de la funkcio anstataŭe de la klara `list` eviti konfuzio de eligo

### la 20-an de Novembro 2017

- ankoraŭ sur SICP ex 1.12

### la 19-an de Novembro 2017

- provadante sur diversaj strukturoj de la kodo por SICP 1.12

### la 17-an de Novembro 2017

- ex-01-12.rkt
  + fariĝis unuan paŝon pli proksiman al efektivigante la vola strukturo sed reiris triaj paŝoj tial
    ke de la kaŝo de la kodo

### la 16-an de Novembro 2017

- ankoraŭ ekzamenas dividaĵo de la kodo de ex-01-12.rkt
  + ĉefa informo al eksponas estas bone sed la strukturo de la efiko estas nune bizara

### la 14-an de Novembro 2017

- ekzamenas kion dividaĵo de la kodo de ex-01-12.rkt al modifikas

### la 13-an de Novembro 2017

- nune laboras sur ex-01-12.rkt (Triangulo de Paskalo)
  + rigardis, Lekcio 1b: _Procedures and Processes; Substitution Model_ (Ĉapitro 1.2 en SICP)

### la 10-an de Novembro 2017

- laboras ankoraŭ sur ex-01-12.rkt (Triangulo de Paskalo)
  + rigardis, SICP filmeta lekcio 1a

### la 9-an de Novembro 2017

- laboras ankoraŭ sur ex-01-12.rkt (Triangulo de Paskalo)

### la 7-an de Novembro 2017

- nune faras ex-01-12.rkt (Triangulo de Paskalo)

### la 6-an de Novembro 2017

- `git push` ex-01-11.rkt

### la 5-an de Novembro 2017

- preskaŭ farinte pri ex-01-11.rkt (sur la vojo al eksplikante la rezonon de la pararametro de la
  iteracia procezo)

### la 3-an de Novembro 2017

- Detala klarigo de ekzerco 1.11 sub kunmetado

### la 2-an de Novembro 2017

- laboras ankaŭ sur ekzerco 1.11

### la 31-an de Oktobro 2017

- laboras ankaŭ sur ekzerco 1.11

### la 30-an de Oktobro 2017

- legis, SICP ĝis paĝo 122.6
  + laboras sur ekzerco 1.11 (el rikura procezo al iteraciata procezo)

### la 29-an de Oktobro 2017

- `git push` ex-01-10.rkt

### la 27-an de Oktobro 2017

- legis, SICP ĝis paĝo 114.0
  + ackermann ekzerco 1.10
  + `git push` ex-01-09.rkt; nune laboras sur ex-01-10.rkt

### la 26-an de Oktobro 2017

- legis, SICP ĝis paĝo 112.0
  + ĉesis, al ekzerco 1.9

### la 17-an de Oktobro 2017

- legis, SICP ĝis 109.2 de 1252
  + sur subsekcio _1.2.1 Linear recursion and iteration_


Subĉapitro 1.1: La konsistigaĵoj de Programado
----------------------------------------------

- Ĉi tio subĉapitro ĉefe priparolas pri la mekanismoj por kombinante la simplaj ideoj por fariĝi la
  malsimplaj ideoj.

### la 16-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.8: _/Procedures as Black-Box Abstractions/_
- legis, SICP ĝis paĝo 98.5 de 1252
  + legis, ĝis numero 11 de _Footnotes_ sekcio

### la 13-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.8: _/Procedures as Black-Box Abstractions/_
- legis, SICP ĝis paĝo 90.7 de 1252
  + legis, ĝis deveno de _Local names_ sub _Procedures as Black Box Abstractions_
  + `git push` SICP  1.7 kaj 1.8 solvoj

### la 12-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.7: _/Example: Square Roots by Newton’s Method/_
- finis, dividaĵon de la klarigo de ekzerco 1.7, nur la optimumiga dividaĵon de la kodo de la
  ekzerco restas

### la 10-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.7: _/Example: Square Roots by Newton’s Method/_
- `git push` solvo al ekzerco 1.6, finis ekzerco 1.8 unue, ekzerco 1.7 preskaŭ farite.

### la 8-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.6: _/Conditional Expressions and Predicates/_
- disdividis, ekzistantan ex-01-01.rkt en al apartaj ekzercaj dosieroj

### la 6-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.6: _/Conditional Expressions and Predicates/_
- `git push` ĝisdatigatajn SICP kompilado de solvoj (aldonis solvon por 1.4 kaj 1.5)

### la 5-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.6: _/Conditional Expressions and Predicates/_
- `git push` solvo al ekzerco 1.3 de SICP

### la 3-an de Oktobro 2017

- Ĉapitro 1: _/Building Abstractions with Procedures/_
  + Subĉapitro 1.1.6: _/Conditional Expressions and Predicates/_
- legis, SICP libron ĝis paĝo 78.6 (se malfermis per Calibre) kaj `git push` ex-01-01.rkt al “sicp”
  deponejo

